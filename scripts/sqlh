#!/bin/bash
#! shellcheck disable=SC2086
#X Function|Global|Local|Script: 
#X Desc    : 
#X Synopsis: 
#X Options :
#X Example : 
#X Depends :
#X See Also:
source "$OKROOT/entities/entities.bash" new || exit 2
	version.set '0.9'
	verbose.set on
	trap.set on
	strict.set on
	msg.prefix.set "$PRG"
	msg.prefix.separator.set '> '
	
	declare -xg Profile='' ProfileStr=''
	declare -xg Database='' DataTable='' DataCommand=''

main() {
	while (( $# )); do
		case "$1" in
			-p|--profile)	shift; Profile="$1";;
			-V|--version)	msg "$(version.set)"; return 0;;
			-h|--help)		usage; return 0;;
			-?|--*)				msg.err "Invalid option [$1]"; return 1;;
			*)						if   [[ -z $Database ]]; 	  then Database="$1"
										elif [[ -z $DataTable ]];   then DataTable="$1";
										elif [[ -z $DataCommand ]]; then DataCommand="$1"
										else
											msg.err "Too many parameters [$1]"
											return 1
										fi
										;;
		esac
		shift
	done
	[[ -z $DataCommand && -n $DataTable ]] && DataCommand='fields'

	if [[ -n $Profile ]]; then
		[[ -f $Profile ]] || { msg.err "Profile [$Profile] not found."; return 2; }
		ProfileStr="--defaults-extra-file=$Profile"
	fi
		
	tabs 8	
	while ((1)); do
		msg.prefix.set "$PRG"
		[[ -n $Database ]] || select_database
		[[ -z $Database ]] && break;
		while ((1)); do
			[[ -n $DataTable ]] || select_table
			[[ -z $DataTable ]] && break
			while ((1)); do
				[[ -n $DataCommand ]] || select_command
				[[ -z $DataCommand ]] && break
				"do_${DataCommand}"
				DataCommand=''
			done
			DataTable=''
		done
		Database=''
	done
}

select_database() {
	local v='' REPLY PS3
	msg.prefix.set ++ 'Databases'
	PS3="$(msg.prefix.set)Select Database: "
	echo
	select v in $(mysql $ProfileStr --no-auto-rehash -Nse 'show databases;' | sort -i); do 
		[[ $REPLY == 'q' ]] && exit 0
		[[ $REPLY == '0' ]] && { v=''; break; }
		[[ -z $v ]] && continue
		break
	done
	Database="$v"
	msg.prefix.set --
}

select_table() {
	local v='' REPLY PS3
	msg.prefix.set ++ "$Database"
	PS3="$(msg.prefix.set)Select Table: "
	echo
	select v in $(mysql $ProfileStr --no-auto-rehash -Nse "use $Database; show tables;" | sort -i); do 
		[[ $REPLY == 'q' ]] && exit 0
		[[ $REPLY == '0' ]] && { v=''; break; }
		[[ -z $v ]] && continue
		break
	done
	DataTable="$v"
	msg.prefix.set --
}

select_command() {
	local v REPLY PS3
	msg.prefix.set ++ "$Database:$DataTable"
	PS3="$(msg.prefix.set)Select Command: "
	local -a cmds
	cmds=(	'structure' 
					'fields'
					'select'
					'command'
					'prompt' 
					''
			 )
	echo
	select v in "${cmds[@]}"; do 
		[[ $REPLY == 'q' ]] && exit 0
		[[ $REPLY == '0' ]] && { v=''; break; }
		[[ -z $v ]] && continue
		break
	done
	DataCommand="${v// /_}"
	msg.prefix.set --
}

do_structure() {
	mysql $ProfileStr --prompt="$(msg.prefix.set)" --no-auto-rehash  "$Database" -e "show columns from $DataTable" || true
	return 0
}

do_command() {
	local cmd='' PS3
	msg.prefix.set ++ "$Database:$DataTable"
	PS3="$(msg.prefix.set)Command: "
	while((1)); do
		read -e -r -p "$PS3" cmd
		[[ -z $cmd || $cmd == '0' || $cmd == 'q' ]] && break
		mysql $ProfileStr --no-auto-rehash "$Database" -e "$cmd" || true
	done
	msg.prefix.set --
	return 0
}

do_prompt() {
	msg.prefix.set '++' "$Database"
	(
		mysql $ProfileStr --no-auto-rehash --prompt="$(msg.prefix.set)mysql> " "$Database"	
	) || true
	msg.prefix.set --
	return 0
}

do_select() {
	local mselect='*' mwhere='' mlimit='100' morder='' PS3
	msg.prefix.set ++ "$Database:$DataTable"
	PS3="$(msg.prefix.set)Select: "
	while((1)); do
		PS3="$(msg.prefix.set)SELECT: "
		read -i "$mselect" -e -r -p "$PS3" mselect
		[[ $mselect == 'q' ]] && exit 0; [[ -z $mselect || $mselect == '0' ]] && break
		PS3="$(msg.prefix.set)WHERE: "
		read -i "$mwhere" -e -r -p "$PS3" mwhere
		[[ $mselect == 'q' ]] && exit 0; [[ -z $mselect || $mselect == '0' ]] && break
		PS3="$(msg.prefix.set)ORDER: "
		read -i "$morder" -e -r -p "$PS3" morder
		[[ $mselect == 'q' ]] && exit 0; [[ -z $mselect || $mselect == '0' ]] && break
		PS3="$(msg.prefix.set)LIMIT: "
		read -i "$mlimit" -e -r -p "$PS3" mlimit
		[[ $mselect == 'q' ]] && exit 0; [[ -z $mselect || $mselect == '0' ]] && break
		(	selectstr="SELECT $mselect FROM $DataTable 								\
								$([[ -n $mwhere ]] && echo "WHERE $mwhere") 		\
								$([[ -n $morder ]] && echo "ORDER BY $morder")  \
								$([[ -n $mlimit ]] && echo "LIMIT $mlimit")"
			msg "$(remsp2 "$selectstr")"
			mysql $ProfileStr --no-auto-rehash "$Database" -e "$selectstr" || perror $?
		) || true
	done
	msg.prefix.set --
	return 0
}

do_fields() {
	local -a flds
	local fld
	local db="$Database" table="$DataTable" 
	if (( $# )); then
		db="$1"
		shift
		(( $# )) && table="$1"
	fi
	msg.prefix.set ++ "$db:$table"
	msg.info 'Fields: '
	flds=( $(mysql $ProfileStr -Nse "use information_schema; 
							SELECT concat(COLUMN_NAME,'~',replace(COLUMN_TYPE,' ','~')) FROM COLUMNS 
									WHERE TABLE_SCHEMA='$db' AND TABLE_NAME='$table';") )
	for fld in "${flds[@]}"; do
		echo -n "[${fld//\~/ }]  "
	done
	echo ''
	msg.prefix.set --
}

cleanup() {
	local -i err=$?
	[[ -z ${1:-} ]] && err=$1
	((err>1)) && errno "$err"
	exit "$err"
}

usage() {
	cat <<-usage
		Script  : $PRG
		Desc    : MySQL helper script to quickly view data/structure.
		Synopsis: $PRG [database [table [command]]] [-p profile] [-V] [-h]
		        :   -p|--profile  Specify mysql profile [eg, /root/.my3.cnf].
		        :   -V|--version  Print version.
		        :   -h|--help     This help.
		        : To back out of a menu, select 0.
		        : To exit, select q.
		Examples: 0. $PRG         # direct to database selection
		        : 1. $PRG Users   # open db Userss, then to table selection.
		        : 2. $PRG Users users fields # open table Users:user and show fields. 
		        : 3. $PRG -p /root/my3.cnf   # open mysql with profile. 
		Requires: mysql-cli
	usage
}

main "$@"
#fin
