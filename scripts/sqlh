#!/bin/bash
#X Function|Global|Local|Script: 
#X Desc    : 
#X Synopsis: 
#X Options :
#X Example : 
#X Depends :
#X See Also:
source "$OKROOT/entities/entities.bash" new || exit 2
	version.set '0.9'
	verbose.set on
	trap.set on
	strict.set on
	msg.prefix.set "$PRG"
	msg.prefix.separator.set '> '
	
	declare -xg Profile ProfileStr
	declare -xg Database='' DataTable='' DataCommand=''

main() {
	while (( $# )); do
		case "$1" in
			-p|--profile)	shift; Profile="$1";;
			-V|--version)	msg "$(version.set)"; return 0;;
			-h|--help)		usage; return 0;;
			-?|--*)				msg.err "Invalid option [$1]"; return 1;;
			*)						if   [[ -z $Database ]]; 	  then Database="$1"
										elif [[ -z $DataTable ]];   then DataTable="$1";
										elif [[ -z $DataCommand ]]; then DataCommand="$1"
										else
											msg.err "Too many parameters [$1]"
											return 1
										fi
										;;
		esac
		shift
	done
	[[ -z $DataCommand && -n $DataTable ]] && DataCommand='fields'
		
	tabs 8	
	while ((1)); do
		msg.prefix.set "$PRG"
		[[ -n $Database ]] || select_database
		[[ -z $Database ]] && break;
		while ((1)); do
			[[ -n $DataTable ]] || select_table
			[[ -z $DataTable ]] && break
			while ((1)); do
				[[ -n $DataCommand ]] || select_command
				[[ -z $DataCommand ]] && break
				"do_${DataCommand}"
				DataCommand=''
			done
			DataTable=''
		done
		Database=''
	done
}

select_database() {
	local v REPLY PS3
	msg.prefix.set ++ 'Databases'
	PS3="$(msg.prefix.set)Select Database: "
	echo
	select v in $(mysql --no-auto-rehash -Nse 'show databases;' | sort -i); do 
		[[ $REPLY == '0' || $REPLY == 'q' ]] && { v=''; break; }
		[[ -z $v ]] && continue
		break
	done
	Database="$v"
	msg.prefix.set --
}

select_table() {
	local v REPLY PS3
	msg.prefix.set ++ "$Database"
	PS3="$(msg.prefix.set)Select Table: "
	echo
	select v in $(mysql --no-auto-rehash -Nse "use $Database; show tables;" | sort -i); do 
		[[ $REPLY == '0' || $REPLY == 'q' ]] && { v=''; break; }
		[[ -z $v ]] && continue
		break
	done
	DataTable="$v"
	msg.prefix.set --
}

select_command() {
	local v REPLY PS3
	msg.prefix.set ++ "$Database:$DataTable"
	PS3="$(msg.prefix.set)Select Command: "
	local -a cmds
	cmds=(	'structure' 
					'fields'
					'select'
					'command'
					'prompt' 
					''
			 )
	echo
	select v in "${cmds[@]}"; do 
		[[ $REPLY == '0' || $REPLY == 'q' ]] && { v=''; break; }
		[[ -z $v ]] && continue
		break
	done
	DataCommand="${v// /_}"
	msg.prefix.set --
}

do_structure() {
	mysql --prompt="$(msg.prefix.set)" --no-auto-rehash  "$Database" -e "show columns from $DataTable" || true
	return 0
}

do_command() {
	local cmd='' PS3
	msg.prefix.set ++ "$Database:$DataTable"
	PS3="$(msg.prefix.set)Command: "
	while((1)); do
		read -e -r -p "$PS3" cmd
		[[ -z $cmd || $cmd == '0' || $cmd == 'q' ]] && break
		mysql --no-auto-rehash "$Database" -e "$cmd" || true
	done
	msg.prefix.set --
	return 0
}

do_prompt() {
	msg.prefix.set '++' "$Database"
	(
		mysql --no-auto-rehash --prompt="$(msg.prefix.set)mysql> " "$Database"	
	) || true
	msg.prefix.set --
	return 0
}

do_select() {
	local mselect='*' mwhere='' mlimit='100' morder='' PS3
	msg.prefix.set ++ "$Database:$DataTable"
	PS3="$(msg.prefix.set)Select: "
	while((1)); do
		PS3="$(msg.prefix.set)SELECT: "
		read -i "$mselect" -e -r -p "$PS3" mselect
		[[ -z $mselect || $mselect == '0' || $mselect == 'q' ]] && break
		PS3="$(msg.prefix.set)WHERE: "
		read -i "$mwhere" -e -r -p "$PS3" mwhere
		[[ $mwhere == '0' || $mwhere == 'q' ]] && break
		PS3="$(msg.prefix.set)ORDER: "
		read -i "$morder" -e -r -p "$PS3" morder
		[[ $morder == '0' || $morder == 'q' ]] && break
		PS3="$(msg.prefix.set)LIMIT: "
		read -i "$mlimit" -e -r -p "$PS3" mlimit
		[[ $mlimit == '0' || $mlimit == 'q' ]] && break
		(	selectstr="SELECT $mselect FROM $DataTable 								\
								$([[ -n $mwhere ]] && echo "WHERE $mwhere") 		\
								$([[ -n $morder ]] && echo "ORDER BY $morder")  \
								$([[ -n $mlimit ]] && echo "LIMIT $mlimit")"
			msg "$(remsp2 "$selectstr")"
			mysql --no-auto-rehash "$Database" -e "$selectstr" || perror $?
		) || true
	done
	msg.prefix.set --
	return 0
}

do_fields() {
	local -a flds
	local fld
	local db="$Database" table="$DataTable" 
	if (( $# )); then
		db="$1"
		shift
		(( $# )) && table="$1"
	fi
	msg.prefix.set ++ "$db:$table"
	msg.info 'Fields: '
	flds=( $(mysql -Nse "use information_schema; 
							SELECT concat(COLUMN_NAME,'~',replace(COLUMN_TYPE,' ','~')) FROM COLUMNS 
									WHERE TABLE_SCHEMA='$db' AND TABLE_NAME='$table';") )
	for fld in "${flds[@]}"; do
		echo -n "[${fld//\~/ }]  "
	done
	echo ''
	msg.prefix.set --
}

cleanup() {
	local -i err=$?
	[[ -z ${1:-} ]] && err=$1
	((err>1)) && errno "$err"
	exit "$err"
}

usage() {
	cat <<-usage
		Script  : $PRG
		Synopsis: $PRG [-V] [-h]
		        : To exit or back out of a menu, select 0.
		Desc    : Command-driven mysql helper script.
	usage
}

main "$@"
#fin
