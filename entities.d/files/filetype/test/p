#!/bin/bash
	source entities.bash new || { echo >&2 "Could not open entities.bash!"; exit 1; }
	strict.set off
	verbose.set on
	trap.set on

	# read/create $PRG.conf file
	declare -x p_Default_Editor='/usr/bin/joe'
	tmp="/etc/entities/$(basename "$0").conf"		# allow user to rename p program
	if [[ ! -f "$tmp" ]]; then
		mkdir -p "$(dirname "$tmp")"
		echo '#!/bin/bash' > "$tmp"
		echo "p_Default_Editor=\"${EDITOR:-/usr/bin/joe -tab 2 --wordwrap -autoindent}\"" >> "$tmp"
	fi
	source "$tmp" || exit	
	export EDITOR="$p_Default_Editor"
	[[ -z "$EDITOR" ]] &&	export EDITOR="$(which nano)"
	
	tmpfile=/tmp/p-$RANDOM
	CH9=$'\t'

main() {
	local file=''
	local -i line=0
	local ftype='' syntaxarg=''
	local -i syntaxerr=0
	local -l execute=0

	cmd=()
	while (($#)); do
		case "$1" in
			-l|--line)		line=$(($2)); shift ;;
			-s|--shellcheck)	shellcheck=1 ;;
			-x|--execute)	execute=1 ;;
			-h|-?|--help)	usage exit ;;
			-v|--verbose)	verbose on ;;
			-q|--quiet)		verbose off ;;
			*)						cmd+=( "$1" ) ;;
		esac
		shift
	done
	(( ${#cmd[@]} == 1 )) || usage exit;
	file="$(readlink -f "${cmd[0]}")"

	$(p_open_file "$file")

if ((0)); then #skip
	if [[ ! -f "${file}" ]]; then
		if [[ -f "${file}.php" ]]; then
			ftype='php'
		elif [[ -f "${file}.sh" ]]; then
			ftype='sh'
		else
			msg.die "File '$file' not found!"
		fi
		file="${file}.${ftype}"
	else
		ext="${file##*.}"
		if 		[[ "$ext" == 'php' ]];	then 
			ftype='php'
		elif 	[[ "$ext" == 'sh'	|| "$ext" == 'bash' ]]; then 
			ftype='sh'
		else
			hd=$(head -n1 "$file")
			hd=${hd%% *}
			if [[ $hd == "#!$(which bash)" || $hd == "#!$(which sh)" ]]; then 
				ftype='sh' 
			elif [[ $hd == "#!$(which php)" || "${hd:0:2}" == '<?' ]]; then 
				ftype='php' 
			else 
				ask.yn "No hashbang found. Use bash?" || \
					msg.die "$file is not a bash or php script!"
				ftype='sh'
				syntaxarg='-syntax sh'
			fi
		fi
	fi

	$EDITOR $syntaxarg $( ((line)) && echo "+${line}" ) "$file"
fi #^^skip

	if [[ "${ftype}" == 'php' ]]; then
		msg.info "$(php -l "${file}" 2>&1 | tee "$tmpfile")"
		hd="$(head -n1 "$tmpfile")"
		if [[ "${hd:0:9}" != 'No syntax' ]]; then
			syntaxerr=1
			l=$(trim "${hd##*on line }")
			if [[ -z "$l" ]]; then line=0
												else line=$(( l ))
			fi
		fi
	else
		msg.info "$(bash -n "${file}" 2>&1 | tee "$tmpfile")"
		hd="$(head -n1 "$tmpfile")"
		if [[ "${hd}" != '' ]]; then
			syntaxerr=1
			l="${hd##*: line }"
			l=${l//${CH9}/ }
			l=$(trim "${l%%:*}")
			if [[ -z "$l" ]]; then line=0
												else line=$l
			fi
		fi
	fi

	if ((syntaxerr)); then
		if ask.yn "Re-edit $file [$line]?"; then
			$PRGDIR/$PRG "$file" --line $line $( ((execute)) && echo '-x' )
			exit
		fi
	fi

	if ((shellcheck)); then
		$(which shellcheck) "$file"
	fi

	if ((execute && syntaxerr==0)); then
		if ask.yn "Execute $file?"; then
			if [[ $ftype == 'php' ]]; then
				$(which php) "$file"
			elif [[ $ftype == 'sh' ]]; then
				$(which bash) "$file"
			fi
		fi
	fi
}


cleanup() {
	if [[ -z "$1" ]]; then exitcode=$?
										else exitcode=$(($1))
	fi
	rm -f "$tmpfile"
	exit $exitcode
}

p_open_file() {
	local file="${1}"
	local ftype=()
	local syntaxarg=''
	ftype=( $(get_filetype "$file" "$EDITOR") )
	[[ ${ftype[1]} == '-' ]] && ftype[1]='sh'
	# syntax argument
	case "$(basename "$(which "$EDITOR")")" in
		joe) syntaxarg="-syntax ${ftype[1]}";;
		nano) syntaxarg="--syntax=${ftype[1]}";;
		*)		syntaxarg=''
	esac
	echo "$EDITOR $syntaxarg ${ftype[0]}"
}

get_filetype() {
	local file="$(readlink -f "${1}")"
	local editor="${2:-}"; editor=${editor%% *};#remove parameters
	local fileext="${file##*.}"
	local syntax='sh'
	local -i fileexist=$([[ -f "$file" ]] && echo 1 || echo 0)

	# see if a syntax file can be found
	syntax="$(lookup_syntax_definition "$editor" "$fileext")"
	[[ -n $syntax ]] && { echo "$file" "$syntax" $fileexist 'lookup'; return; }

	# determine ftype by file extension
	case "$fileext" in
		bash|sh)			echo "$file" 'sh'		$fileexist 'ext'; return;;
		php|html|htm)	echo "$file" 'php'	$fileexist 'ext'; return;;
	esac

	# if file not found then cycle through possible file extensions
	if ((! fileexist)); then
		for ex in php htm html; do
			[[ -f $file.$ex ]] && { echo "$file.$ex" 'php' $fileexist 'nf-ext'; return; }
		done
		for ex in bash sh conf cfg; do
			[[ -f $file.$ex ]] && { echo "$file.$ex" 'sh' $fileexist 'nf-ext'; return; }
		done
		# file was not found
		echo "$file" '-' $fileexist 'nf-ext'
		return 1
	fi

	# head examination
	hd=$(head -n1 "$file")
	hd=${hd%% *}; hd=${hd,,}	# grab everything up to first space, then lowercase
	if [[ "$hd" == "#!$(which bash)" ]] || [[ "$hd" == "#!$(which sh)" ]] || [[ "$hd" == "#!$(which env)" ]]; then
		echo "$file" 'sh' $fileexist 'head'; return 0
	elif [[ "$hd" == "#!$(which php)" ]] || [[ "${hd:0:2}" == '<?' ]]; then
		echo "$file" 'php' $fileexist 'head'; return 0
	elif [[ "${hd:0:9}" == '<!doctype' ]] || [[ "${hd:0:5}" == '<html' ]]; then
		echo "$file" 'php' $fileexist 'head'; return 0
	fi
	# file was not identified as php or sh
	echo "$file" '-' $fileexist 'noidea'
	return 0
}

# look in syntax files for matching ext
lookup_syntax_definition() {
	local editor="$1" fileext="$2"
	[[ -z "$fileext" ]] && { echo ''; return; }
	editor=$(basename "$(which "$editor")")
	case "$editor" in
		joe)
			[[ -f /usr/share/joe/syntax/$fileext.jsf ]]	&& echo "$fileext";;
		nano)
			[[ -f /usr/share/nano/$fileext.nanorc ]]		&& echo "$fileext";;
		*)	echo '';;
	esac
	return 0
}

usage() {
	msg "Usage: $(basename "$0") filename[.php|.sh|.bash] [--line|-l rownum] [-x]"
	tab.set ++
	msg.info "Edit and syntax check file, starting at rownum if specified."
	msg.info "Scripts without .sh or .bash extentions are autodetected from header (#!$(which bash))."
	tab.set ++
	msg.info "-l position cursor at row rownum on entry to editor."
	msg.info "-s execute shellcheck for bash scripts after editing."
	msg.info "-x execute script after editting (asks first)."
	tab.set 0
	msg.info "Editor config file: /etc/entities/$(basename "$0").conf"
	msg.info "Current EDITOR: [$EDITOR]"
	exit 1
}

main "$@"
#fin
